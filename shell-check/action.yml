# Copyright (c) 2025, NVIDIA CORPORATION.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: 'Shell Script Syntax Check'
description: 'check shell script syntax'
inputs:
  included_file_patterns:
    description: "Comma-separated list of file patterns to include (e.g., '*.sh,*.bash')"
    required: true
    type: string
  excluded_file_patterns:
    description: "Comma-separated list of file patterns to exclude (e.g., 'src/**')"
    required: false
    type: string
    default: ""

runs:
  using: "composite"
  steps:
    - name: Install shellcheck
      shell: bash
      run: |
        sudo apt-get update
        sudo apt-get install -y shellcheck
      env:
        DEBIAN_FRONTEND: noninteractive

    - name: Check shell scripts
      shell: bash
      run: |
        # Initialize variables
        error_log="shell_errors.log"
        error_count=0
        failed_files=()
        
        # Clean up any previous error log
        rm -f "$error_log"
        
        # Format file patterns
        IFS="," read -r -a INCLUDE_PATTERNS <<< "$(echo "${{ inputs.included_file_patterns }}" | tr -d ' ' | tr -d '\n')"
        IFS="," read -r -a EXCLUDE_PATTERNS <<< "$(echo "${{ inputs.excluded_file_patterns }}" | tr -d ' ' | tr -d '\n')"
        echo "Included file patterns: ${INCLUDE_PATTERNS[@]}"
        echo "Excluded file patterns: ${EXCLUDE_PATTERNS[@]}"

        # Get changed files
        BASE_REF=$(git --no-pager log --oneline -1 | awk '{ print $NF }')
        echo "Base REF: ${BASE_REF}"
        FILES=$(git diff --name-only --diff-filter=AM ${BASE_REF} HEAD) || (echo "Your base commit ID is too old, please try upmerge first." && exit 1)
        RENAME_FILES=$(git diff --name-status ${BASE_REF} HEAD | grep "^R" | grep -v "R100" | awk '{print $3}' || echo "")
        echo "${RENAME_FILES[@]}"
        FILES=($FILES $RENAME_FILES)
        echo "Files to be detected: ${FILES[@]}"

        # Check shell syntax
        for FILE in "${FILES[@]}"; do
          # Skip directories
          [ -d "$FILE" ] && continue
          # Check if file matches include patterns
          included=false
          for pattern in "${INCLUDE_PATTERNS[@]}"; do
            if [[ $FILE == $pattern ]]; then
              included=true
              break
            fi
          done
          excluded=false
          for pattern in "${EXCLUDE_PATTERNS[@]}"; do
            if [[ $FILE == $pattern ]]; then
              excluded=true
              break
            fi
          done
          
          if $included && ! $excluded; then
            echo "üîç Checking: $FILE"
            
            # Create a temporary file for this file's errors
            tmp_error=$(mktemp)
            
            # Check if file exists
            # Run bash -n syntax check
            if ! bash -n "$FILE" 2>&1 | tee -a "$tmp_error"; then
                echo "‚ùå bash -n failed for $FILE" | tee -a "$tmp_error"
                ((error_count++))
            fi
              
            # Run shellcheck
            if ! shellcheck --format=tty --color=always "$FILE" 2>&1 | tee -a "$tmp_error"; then
                echo "‚ùå shellcheck failed for $FILE" | tee -a "$tmp_error"
                ((error_count++))
            fi
            
            # If errors were found, add to main log
            if [ -s "$tmp_error" ]; then
                failed_files+=("$FILE")
                echo -e "\n=== Errors in $FILE ===" >> "$error_log"
                cat "$tmp_error" >> "$error_log"
                echo -e "\n" >> "$error_log"
            fi
            
            rm -f "$tmp_error"
          fi
        done
        
        # Final report
        if [ -s "$error_log" ]; then
          echo -e "\n‚ùå Found $error_count errors in ${#failed_files[@]} files:"
          printf ' - %s\n' "${failed_files[@]}"
          
          echo "::group::Detailed Error Report"
          cat "$error_log"
          echo "::endgroup::"
          
          # Create GitHub annotations for each error
          while IFS= read -r line; do
              if [[ "$line" == *:*:*:* ]]; then
                  # Extract filename, line number, and message
                  file_path=$(echo "$line" | cut -d: -f1)
                  line_num=$(echo "$line" | cut -d: -f2)
                  message=$(echo "$line" | cut -d: -f4- | sed 's/^ *//')
                  
                  echo "::error file=$file_path,line=$line_num::$message"
              fi
          done < "$error_log"
          
          echo "::error::Found $error_count shell script errors"
          exit 1
        else
          echo "‚úÖ No shell script errors found"
        fi
      env:
        SHELLCHECK_OPTS: "-e SC1090 -e SC1091"  # Ignore source not found errors